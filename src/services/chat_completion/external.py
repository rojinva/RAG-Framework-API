from fastapi import HTTPException
from src.models import LamBotChatRequest, LamBotConfig
from src.core.bots import LamBot
from src.core.utils.log_trace import log_trace_event
from src.core.database import LamBotMongoDB
from src.core.chat import ConversationEngine
from dotenv import load_dotenv
from src.models.functions import datetime_now

load_dotenv(override=True)


async def chat_completion_non_streaming(
        lambot_chat_request: LamBotChatRequest, lambot_config: LamBotConfig, trace_id: str, history_context_messages: list
    ):
    """
    Handles non-streaming chat completion requests.

    This function processes a chat request using the LamBot configuration and query configuration.
    It initializes a conversation engine and generates a non-streaming response based on the provided messages.

    Args:
        lambot_chat_request (LamBotChatRequest): The chat request containing user messages and query configuration.
        lambot_config (LamBotConfig): The configuration for the LamBot instance.
        trace_id (str): A unique identifier for tracing the request.
        history_context_messages (list): A list of historical context messages to be appended to the user messages.

    Returns:
        LamBotChatResponse: The response generated by the LamBot conversation engine.

    Raises:
        HTTPException: If a ValueError occurs, raises a 422 Unprocessable Entity error.
    """
    try:
        bot_config = lambot_config
        query_config = lambot_chat_request.query_config
        messages = lambot_chat_request.messages
        history_context_messages.extend(messages)

        # Configures the bot with the provided query config if it's not None, otherwise uses the default query config
        bot = LamBot(bot_config=bot_config, query_config=query_config)

        # Action
        # Instantiate the conversation handler with the bot
        conversation_engine = ConversationEngine(bot)

        log_trace_event(
            trace_id=trace_id,
            step="conversation_engine_started",

        )

        async def generate_non_streaming_response():
            async for response in conversation_engine.generate_response(messages=history_context_messages,
                                                                        trace_id=trace_id,
                                                                        streaming=False):
                return response

        # Return LamBotChatResponse
        response = await generate_non_streaming_response()
        return response

    except Exception as e:
        # If the error is a ValueError, raise a 422 Unprocessable Entity error
        if isinstance(e, ValueError):
            raise HTTPException(422, f"422 error: {e}")
       
def fetch_history_context(
    lambot_id: str,
    thread_id: str,
    username: str,
) -> list:
    """
    Fetch the history context messages based on the provided parameters.

    Args:
        lambot_id (str): The model identifier.
        thread_id (str): The unique identifier for the thread_id message of the conversation.
        userid (str): The user ID.
        dialogsnapshot_n (int, optional): The number of messages to fetch for the dialog snapshot.

    Returns:
        list: A list of history context messages.
    """
    query = {
        "lambotId": lambot_id,
        "threadId": thread_id,
        "username": username,
    }
    try:
        messages = LamBotMongoDB.get_instance().conversations_external_db.fetch_n_messages(query)
    except RuntimeError as e:
        raise HTTPException(status_code=500, detail=str(e))
    return messages


def handle_chat_completion(message_content:str, completion:dict) -> list:
    """
    Handles the processing of chat completion results and prepares the new messages structure.

    Args:
        message_content: The original chat request payload.
        completion: The result of the lambot chat completion process.

    Returns:
        A list of new messages formatted for further processing.
    """
   
    user_message = {
        "user": {
            "content": message_content
        },
        "created_at": datetime_now()
    }

    assistant_message = {
        "assistant": {
            "chunk": completion.chunk,
            "citations": completion.citations or [],
            "followup_questions": completion.followup_questions,
            "tool_artifacts": completion.tool_artifacts or []
        },
        "created_at": datetime_now(),
    }

    return [user_message, assistant_message]
 